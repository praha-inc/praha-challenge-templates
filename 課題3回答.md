## 課題3-1
[課題2](https://www.notion.so/ab782bceba3c45b8bcada7551abb2d8b?pvs=21)の単体テストを書くためには、依存性の注入とモック化を行う必要がありました。
そもそも、なぜ元の関数はカバレッジ100%のテストを書けなかったのでしょうか？
### 回答
例えばNameApiService内で
```ts
const { data } = await axios.get(
    "https://random-data-api.com/api/name/random_name"
);
```
という記述をしているが、この処理で返ってくる値が一定の値ではなく予測できないため、カバレッジ100%を実現することができなかった。


## 課題3-2
依存性の注入とは何でしょうか？どのような問題を解決するために考案されたのでしょうか？
### 回答
ある関数やクラスが依存（利用）するオブジェクトを関数内部で生成するのではなく、引数でオブジェクトのインスタンスを渡すようにして外部から依存オブジェクトを与えてあげる事。
これは疎結合なクラスを構築するために実装する

例えば本実装では以下のように、関数内で依存オブジェクト DatabaseMock のインスタンスを直接生成していた
```ts
export const asyncSumOfArraySometimesZero = (
  numbers: number[]
): Promise<number> => {
  return new Promise((resolve): void => {
    try {
      const database = new DatabaseMock(); // fixme: この関数をテストするには、DatabaseMockの使い方を変える必要がありそう！ヒント：依存性の注入
      database.save(numbers);
      resolve(sumOfArray(numbers));
    } catch (error) {
      resolve(0);
    }
  });
};
```
ただし、この設計では依存オブジェクト( DatabaseMock )を直接使用しているため、テスト時に DatabaseMock をモックに差し替えることが困難となる。

なので、この依存オブジェクトを引数として受け取る形式に変更する。
```ts
export const asyncSumOfArraySometimesZero = (
  database: DatabaseMock, // ここでDI（依存性注入）を使う
  numbers: number[]
): Promise<number> => {
  return new Promise((resolve): void => {
    try {
      const database = new DatabaseMock(); // fixme: この関数をテストするには、DatabaseMockの使い方を変える必要がありそう！ヒント：依存性の注入
      database.save(numbers);
      resolve(sumOfArray(numbers));
    } catch (error) {
      resolve(0);
    }
  });
};
```

そして関数を実行する際に、依存オブジェクトのインスタンスを引数で与えてあげるようにすることによって依存性の注入が再現できる
```ts
const databaseMock1 = {
    save: jest.fn(() => {
        throw new Error("Database error")
    }),
}

const databaseMock2 = {
    save: jest.fn(() => {
        return
    }),
}

expect(asyncSumOfArraySometimesZero(databaseMock1 as unknown as DatabaseMock, [1, 1])).resolves.toBe(0);
expect(asyncSumOfArraySometimesZero(databaseMock2 as unknown as DatabaseMock, [1, 1])).resolves.toBe(2);
```


## 課題3-3
`getFirstNameThrowIfLong`の関数は[https://random-data-api.com](https://random-data-api.xn--com-u63bk2a8fsa8im57aia3a8g86a5dv4bs207bqxxb/)からデータを取得しているようです。しかしテストの度に外部サービスと通信をするようでは、良い単体テストにならない可能性があります。今回のような単体テストで外部サービスとの通信が発生すると、どのようなデメリットがあるでしょうか？
### 回答
以下のようなデメリットが考えられる
- 外部サービスを利用するためにはプログラム側に必要なライブラリーをインストールする必要がある
- ネットにつながっていないと利用できないものもある（WebAPIなど）
- 外部サービスが一定の値を返してくれない場合もあるので、どのような値が返ってくるか予想できないためテストしずらい


## 課題3-4 *任意
テストには「単体テスト」「統合テスト」など様々な分類や定義があります。
チーム内で「何を単体テストと呼ぶのか」「何を統合テストと呼ぶのか」など用語の定義集を作ってみても面白いかもしれません。
### 回答
1. 単体テスト (Unit Test)¥
  - 定義:
    システムの最小単位（関数、メソッド、クラスなど）を個別に検証するテスト。通常は、コードレベルで記述し、外部の依存関係（データベースやAPI）をモックやスタブで置き換える。
  - 目的:
    個々の単位が仕様通りに動作するかを確認。
  - 例:
    関数calculateSumが正しい計算結果を返すか確認。
2. 統合テスト (Integration Test)
  - 定義:
    システムの複数のコンポーネントを組み合わせて、その相互作用を検証するテスト。モジュール間のデータや制御のやり取りに焦点を当てる。
  - 目的:
    コンポーネント間のインターフェースが正しく動作するかを確認。
  - 例:
    ーザー入力を処理し、データベースに保存する機能全体を検証。

## 課題3-5
`sumOfArray`に空の配列を渡すと例外が発生します。あまり好ましい挙動ではありません。
なぜあまり好ましい挙動ではないのでしょうか？
「こうなるべきだ」とご自身が考える形にコードを修正してみてください。
### 回答
- なぜ好ましくないのか
`sumOfArray` というネーミングからすると「空配列の場合だと合計値 0 になるのでは??」という認識になるが、実際は例外を返す使用なので認識にギャップが生まれる。
- 対策として
以下のように reduce の第二引数に初期値を与えることによって、空配列の際の例外の発生を防ぐことができる
```ts
export const sumOfArray = (numbers: number[]): number => {
  return numbers.reduce((a, b) => a + b, 0); // 第二引数に0
};
```

## 課題3-6
コードを修正したら、先ほど書いた単体テストが落ちるはずです。
全ての単体テストが通るよう、単体テストも修正してください。
### 回答
```ts
test('空の配列を渡したら、実行時にエラー発生', () => {
    expect(() => sumOfArray([])).toBe(0);
});
```


## 課題3-7
単体テストを作成する際は、挙動が変わる境界値を検討したり、テストで保証しなければならない挙動を開発者自身が事前に考えておく必要があります。しかし複雑な機能をテストする場合あらかじめ全てのテストケースを開発者が想定しきることは難しいかもしれません。

「この特定の値の時だけ不具合が起きる」ケースを開発者が見落としてしまうと、テストケースが不完全になってしまいます。そんな時に役立つかもしれない概念として「Property Based Testing（プロパティベースのテスト）」があります（対照的な存在としてはExample Based Testingが挙げられます）。

なぜこのテストの考え方がコード品質を向上してくれる可能性があるのでしょうか？
逆に採用しない方が良いケースはあるのでしょうか？
### 回答
- なぜコード品質を向上してくる？
  - テストケースの自動生成することによって、通常のよりも広範囲のシナリオでテストを行うことができる。（つまり、予期せぬエッジケースを洗い出すことができる）
- 採用しない方がいいケースは？
  - 入力と出力が単純な時。その場合、従来のテストで十分カバーできるため。
  - データ生成が困難な複雑なデータ構造や、多くの状態を持つシステムの場合。適切なプロパティとジェネレータの設計が非常に難しくなる可能性がありますり、導入コストもかかる。


## 課題3-8
単体テストケースを増やしても可読性、保守性、実行速度などに問題が起きないよう工夫できることを3つ考えてみましょう。
### 回答
1. テストの構造化とモジュール化
テストを機能ごとにグループ化し、各テストケースの目的を明確にする
```ts
describe('UserService', () => {
  describe('createUser', () => {
    it('should create a new user with valid data', () => {
      // テストコード
    });
    it('should throw an error with invalid data', () => {
      // テストコード
    });
  });

  describe('updateUser', () => {
    it('should update an existing user', () => {
      // テストコード
    });
    it('should throw an error if user does not exist', () => {
      // テストコード
    });
  });

});
```

2. パラメータ化テストの活用
パラメータ化テストとは、テスト定義する際に、同じテストケースを複数の異なる入力値で繰り返し実行する手法。
この例では、fast-checkライブラリを使用してプロパティベーステストを実装している。これにより、多数の異なる入力値でテストを実行でき、エッジケースも自動的にカバーできる。
```ts
import * as fc from 'fast-check';

describe('sortArray', () => {
  it('should sort arrays in ascending order', () => {
    fc.assert(
      fc.property(fc.array(fc.integer()), (arr) => {
        const sorted = sortArray(arr);
        return sorted.every((v, i) => i === 0 || v >= sorted[i - 1]);
      })
    );
  });
});
```

3. テストヘルパー関数の作成
共通のセットアップや検証ロジックをヘルパー関数として抽出することで、テストコードの重複を減らし、保守性を向上させることができる。
```ts
// テストヘルパー関数
function createTestUser(overrides = {}) {
  return {
    id: 1,
    name: 'Test User',
    email: 'test@example.com',
    ...overrides
  };
}

describe('UserService', () => {
  describe('updateUser', () => {
    it('should update an existing user', () => {
      const user = createTestUser();
      const updatedData = { name: 'Updated Name' };
      const result = userService.updateUser(user.id, updatedData);
      expect(result).toEqual({ ...user, ...updatedData });
    });
  });
});
```